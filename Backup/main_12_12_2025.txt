/* USER CODE BEGIN Header */
/**
 ******************************************************************************
 * @file           : main.c
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
/* USER CODE END Header */
/* Includes ------------------------------------------------------------------*/
#include "main.h"

/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include <stdio.h>
/* USER CODE END Includes */

/* Private typedef -----------------------------------------------------------*/
/* USER CODE BEGIN PTD */
typedef enum {
	BTN_IDLE,
	BTN_DEBOUNCE,
	BTN_PRESSED,
	BTN_DEBOUNCE_RELEASE,
	BTN_WAIT_RELEASE,
	BTN_WAIT_SECOND_PRESS,
	BTN_LONG_PRESS_DETECTED  // Thêm state này để track long press đã được gọi
} ButtonState;
/* USER CODE END PTD */

/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
#define UART_DEBUG			huart2

#define DEBOUNCE_MS         100
#define LONG_PRESS_MS       2000
#define DOUBLE_PRESS_MS     1000
/* USER CODE END PD */

/* Private macro -------------------------------------------------------------*/
/* USER CODE BEGIN PM */

/* USER CODE END PM */

/* Private variables ---------------------------------------------------------*/
TIM_HandleTypeDef htim2;

UART_HandleTypeDef huart2;

/* USER CODE BEGIN PV */
volatile ButtonState btn_state = BTN_IDLE;
volatile GPIO_PinState btn_pin_state = GPIO_PIN_RESET;

volatile uint32_t press_time = 0;
volatile uint32_t release_time = 0;
volatile uint32_t debounce_cnt = 0;
volatile uint8_t  press_count = 0;
volatile uint8_t  exti_flag = 0;  // Flag để track EXTI event
/* USER CODE END PV */

/* Private function prototypes -----------------------------------------------*/
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_USART2_UART_Init(void);
static void MX_TIM2_Init(void);
/* USER CODE BEGIN PFP */
#ifdef UART_DEBUG
int _write(int file, char *pData, int len)
{
	// Gửi dữ liệu qua UART1 với timeout 100ms (blocking)
	// HAL_StatusTypeDef status = HAL_UART_Transmit_DMA(&UART_DEBUG, (uint8_t*)pData, len);
	HAL_StatusTypeDef status = HAL_UART_Transmit(&UART_DEBUG, (uint8_t*)pData, len, 100);

	// Trả về len nếu thành công, -1 nếu thất bại
	if (status == HAL_OK) {
		return len;
	} else {
		return -1;  // Gửi thất bại (timeout, error, v.v.)
	}
}
#endif
/* USER CODE END PFP */

/* Private user code ---------------------------------------------------------*/
/* USER CODE BEGIN 0 */

/**
 * Flow xử lý nút nhấn giờ đã đúng:
Short Press: IDLE → DEBOUNCE → PRESSED → DEBOUNCE_RELEASE → WAIT_SECOND_PRESS (timeout) → ShortPress → IDLE
Long Press: IDLE → DEBOUNCE → PRESSED (>=LONG_PRESS_MS) → WAIT_RELEASE → DEBOUNCE_RELEASE → IDLE → LongPress
Double Press: IDLE → DEBOUNCE → PRESSED → DEBOUNCE_RELEASE → WAIT_SECOND_PRESS (EXTI) → DoublePress → IDLE
 */
void On_ShortPress(void) {
	// TODO: your code
	printf("short press\r\n");
}

void On_LongPress(void) {
	// TODO: your code
	printf("long press\r\n");
}

void On_DoublePress(void) {
	// TODO: your code
	printf("double press\r\n");
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
	if (GPIO_Pin == GPIO_PIN_0)
	{
		// Cập nhật trạng thái GPIO ngay lập tức
		btn_pin_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);

		// Set flag để timer callback xử lý (không gọi callback ngay ở đây!)
		exti_flag = 1;
	}
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
	if (htim->Instance == TIM2)   // Timer 1ms
	{
		// Cập nhật trạng thái GPIO hiện tại
		btn_pin_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0);

		switch (btn_state)
		{
		case BTN_IDLE:
			// Chờ EXTI event (nút được nhấn)
			if (exti_flag && btn_pin_state == GPIO_PIN_SET)
			{
				// EXTI rising được confirm → bắt đầu debounce
				btn_state = BTN_DEBOUNCE;
				debounce_cnt = 0;
				exti_flag = 0;
			}
			break;

		case BTN_DEBOUNCE:
			// Sau DEBOUNCE_MS mới công nhận sự kiện
			if (++debounce_cnt >= DEBOUNCE_MS)
			{
				// EXTI rising → PA0 = 1 (SET) = nút nhấn
				if (btn_pin_state == GPIO_PIN_SET)
				{
					btn_state = BTN_PRESSED;
					press_time = 0;
					exti_flag = 0;
				}
				else
				{
					// Nút không nhấn → quay về IDLE
					btn_state = BTN_IDLE;
					exti_flag = 0;
				}
			}
			break;

		case BTN_PRESSED:
			press_time++;

			// Kiểm tra short press (thả nút trước khi đạt long press)
			// PA0 = 0 (RESET) = nút được thả
			if (btn_pin_state == GPIO_PIN_RESET)
			{
				// Nút đã thả sớm → short press, debounce để xác nhận
				btn_state = BTN_DEBOUNCE_RELEASE;
				debounce_cnt = 0;
				exti_flag = 0;
			}
			// Kiểm tra long press
			else if (press_time >= LONG_PRESS_MS)
			{
				// LONG PRESS callback - gọi chỉ 1 lần
				On_LongPress();
				press_time = 0;
				btn_state = BTN_LONG_PRESS_DETECTED; // Chuyển sang state mới
				exti_flag = 0;
			}
			break;

		case BTN_DEBOUNCE_RELEASE:
			// Debounce khi thả nút
			if (++debounce_cnt >= DEBOUNCE_MS)
			{
				// PA0 = 0 (RESET) = nút đã thả hoàn toàn
				if (btn_pin_state == GPIO_PIN_RESET)
				{
					// Xác nhận nút đã thả hoàn toàn → chờ lần nhấn thứ 2
					btn_state = BTN_WAIT_SECOND_PRESS;
					press_count++;
					release_time = 0;
					exti_flag = 0;
				}
				else
				{
					// Nút vẫn nhấn (false release) → quay lại BTN_PRESSED
					btn_state = BTN_PRESSED;
					// press_time tiếp tục đếm (không reset)
					exti_flag = 0;
				}
			}
			break;

		case BTN_WAIT_SECOND_PRESS:
			release_time++;

			// // Kiểm tra EXTI event (lần nhấn thứ 2)
			// if (exti_flag && btn_pin_state == GPIO_PIN_SET)
			// {
			// 	// Lần nhấn thứ 2 được confirm → double press
			// 	On_DoublePress();
			// 	press_time = 0;
			// 	press_count = 0;
			// 	btn_state = BTN_IDLE;
			// 	exti_flag = 0;
			// }
			// else if (release_time >= DOUBLE_PRESS_MS)
			// {
			// 	// Timeout - không có lần nhấn thứ 2
			// 	if (press_count == 1)
			// 		On_ShortPress();

			// 	press_count = 0;
			// 	press_time = 0;
			// 	btn_state = BTN_IDLE;
			// 	exti_flag = 0;
			// }
			// break;
			// Kiểm tra EXTI event (lần nhấn thứ 2)
			
			if (release_time >= DOUBLE_PRESS_MS)
			{
				// Timeout - không có lần nhấn tiếp theo
				if (press_count == 1)
					On_ShortPress();
				else if (press_count == 2)
					On_DoublePress();
				
				press_count = 0;
				press_time = 0;
				btn_state = BTN_IDLE;
				exti_flag = 0;
			}
			break;
		
			case BTN_WAIT_RELEASE:
			// PA0 = 0 (RESET) = nút được thả
			if (btn_pin_state == GPIO_PIN_RESET)
			{
				// Thả sau long press - quay về IDLE (không cần debounce)
				btn_state = BTN_IDLE;
				exti_flag = 0;
			}
			break;

		case BTN_LONG_PRESS_DETECTED:
			// State này chờ nút được thả sau khi long press được gọi
			// PA0 = 0 (RESET) = nút được thả
			if (btn_pin_state == GPIO_PIN_RESET)
			{
				// Nút đã thả, quay về IDLE
				btn_state = BTN_IDLE;
				exti_flag = 0;
			}
			break;

		default:
			break;
		}
	}
}


/* USER CODE END 0 */

/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{

	/* USER CODE BEGIN 1 */

	/* USER CODE END 1 */

	/* MCU Configuration--------------------------------------------------------*/

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* USER CODE BEGIN Init */

	/* USER CODE END Init */

	/* Configure the system clock */
	SystemClock_Config();

	/* USER CODE BEGIN SysInit */

	/* USER CODE END SysInit */

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
	MX_USART2_UART_Init();
	MX_TIM2_Init();
	/* USER CODE BEGIN 2 */
	HAL_TIM_Base_Start_IT(&htim2);
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, 1);
	printf("waiting.....\r\n");

	/* USER CODE END 2 */

	/* Infinite loop */
	/* USER CODE BEGIN WHILE */
	while (1)
	{
		// btn_pin_state được cập nhật trong EXTI callback và TIM callback
		// Không cần cập nhật ở đây nữa
		//    printf("Hello World\r\n");
		//    HAL_Delay(200);
		printf("btn_state: %d, btn_pin_state: %d, press_count: %d press_time: %ld\r\n",
       btn_state, btn_pin_state, press_count, press_time);
	   HAL_Delay(200);
		/* USER CODE END WHILE */

		/* USER CODE BEGIN 3 */
	}
	/* USER CODE END 3 */
}

/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
	RCC_OscInitTypeDef RCC_OscInitStruct = {0};
	RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

	/** Initializes the RCC Oscillators according to the specified parameters
	 * in the RCC_OscInitTypeDef structure.
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
	RCC_OscInitStruct.HSIState = RCC_HSI_ON;
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
	{
		Error_Handler();
	}

	/** Initializes the CPU, AHB and APB buses clocks
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
			|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
	{
		Error_Handler();
	}
}

/**
 * @brief TIM2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_TIM2_Init(void)
{

	/* USER CODE BEGIN TIM2_Init 0 */

	/* USER CODE END TIM2_Init 0 */

	TIM_ClockConfigTypeDef sClockSourceConfig = {0};
	TIM_MasterConfigTypeDef sMasterConfig = {0};

	/* USER CODE BEGIN TIM2_Init 1 */

	/* USER CODE END TIM2_Init 1 */
	htim2.Instance = TIM2;
	htim2.Init.Prescaler = 72-1;
	htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
	htim2.Init.Period = 1000-1;
	htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
	if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
	{
		Error_Handler();
	}
	sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
	if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
	{
		Error_Handler();
	}
	sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
	sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
	if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN TIM2_Init 2 */

	/* USER CODE END TIM2_Init 2 */

}

/**
 * @brief USART2 Initialization Function
 * @param None
 * @retval None
 */
static void MX_USART2_UART_Init(void)
{

	/* USER CODE BEGIN USART2_Init 0 */

	/* USER CODE END USART2_Init 0 */

	/* USER CODE BEGIN USART2_Init 1 */

	/* USER CODE END USART2_Init 1 */
	huart2.Instance = USART2;
	huart2.Init.BaudRate = 115200;
	huart2.Init.WordLength = UART_WORDLENGTH_8B;
	huart2.Init.StopBits = UART_STOPBITS_1;
	huart2.Init.Parity = UART_PARITY_NONE;
	huart2.Init.Mode = UART_MODE_TX_RX;
	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
	huart2.Init.OverSampling = UART_OVERSAMPLING_16;
	if (HAL_UART_Init(&huart2) != HAL_OK)
	{
		Error_Handler();
	}
	/* USER CODE BEGIN USART2_Init 2 */

	/* USER CODE END USART2_Init 2 */

}

/**
 * @brief GPIO Initialization Function
 * @param None
 * @retval None
 */
static void MX_GPIO_Init(void)
{
	GPIO_InitTypeDef GPIO_InitStruct = {0};
	/* USER CODE BEGIN MX_GPIO_Init_1 */

	/* USER CODE END MX_GPIO_Init_1 */

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOD_CLK_ENABLE();
	__HAL_RCC_GPIOA_CLK_ENABLE();
	__HAL_RCC_GPIOB_CLK_ENABLE();

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, GPIO_PIN_RESET);

	/*Configure GPIO pin : PA0 */
	GPIO_InitStruct.Pin = GPIO_PIN_0;
	GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

	/*Configure GPIO pin : PB2 */
	GPIO_InitStruct.Pin = GPIO_PIN_2;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

	/* EXTI interrupt init*/
	HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
	HAL_NVIC_EnableIRQ(EXTI0_IRQn);

	/* USER CODE BEGIN MX_GPIO_Init_2 */

	/* USER CODE END MX_GPIO_Init_2 */
}

/* USER CODE BEGIN 4 */

/* USER CODE END 4 */

/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
	{
	}
	/* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
 * @brief  Reports the name of the source file and the source line number
 *         where the assert_param error has occurred.
 * @param  file: pointer to the source file name
 * @param  line: assert_param error line source number
 * @retval None
 */
void assert_failed(uint8_t *file, uint32_t line)
{
	/* USER CODE BEGIN 6 */
	/* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
	/* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
